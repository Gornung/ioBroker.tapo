{
  "version": 3,
  "sources": ["../../../src/lib/utils/newTpLinkCipher.ts"],
  "sourcesContent": ["import crypto from \"crypto\";\n\nexport default class NewTpLinkCipher {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public iv: any;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public key: any;\n  private _crypto = crypto;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public sig: any;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public seq: any;\n\n  constructor(\n    localSeed: Buffer,\n    remoteSeed: Buffer,\n    authHash: Buffer | undefined,\n    public readonly log: any,\n  ) {\n    if (authHash) {\n      this.calculateKey(localSeed, remoteSeed, authHash);\n      this.calculateIvSeq(localSeed, remoteSeed, authHash);\n      this.calculateSig(localSeed, remoteSeed, authHash);\n    }\n  }\n\n  public encrypt(data: Buffer | string) {\n    this.seq += 1;\n\n    if (typeof data === \"string\") {\n      data = Buffer.from(data, \"utf8\");\n    }\n\n    const cipher = this._crypto.createCipheriv(\"aes-128-cbc\", this.key, this.ivSeqPair());\n    const cipherText = Buffer.concat([cipher.update(data), cipher.final()]);\n\n    const seqBuffer = Buffer.alloc(4);\n    seqBuffer.writeInt32BE(this.seq, 0);\n\n    const hash = this._crypto.createHash(\"sha256\");\n    hash.update(Buffer.concat([this.sig, seqBuffer, cipherText]));\n\n    const signature = hash.digest();\n\n    return {\n      encryptedPayload: Buffer.concat([signature, cipherText]),\n      seq: this.seq,\n    };\n  }\n\n  public decrypt(data: Buffer) {\n    const decipher = this._crypto.createDecipheriv(\"aes-128-cbc\", this.key, this.ivSeqPair());\n    const decrypted = Buffer.concat([decipher.update(data.subarray(32)), decipher.final()]);\n\n    const dec = decrypted.toString(\"utf8\");\n    this.log.debug(\"decrypted: \" + dec);\n\n    //Some times the json returned is malformed, or the number returned in error_code\n    //is not valid e.g. -0301, so we need to use regex to replace the malformed/invalid json parts\n    let dec_fixed = \"\";\n    if (dec.match(/{\"error_code\":([-0-9]+)[^,}]$/)) {\n      dec_fixed = dec.replace(/{\"error_code\":([-0-9]+)[^,}]/gm, '{\"error_code\":\"$1\"}');\n    } else if (dec.match(/{\"error_code\":([-0-9]+)}$/)) {\n      dec_fixed = dec.replace(/{\"error_code\":([-0-9]+)}$/gm, '{\"error_code\":\"$1\"}');\n    } else {\n      dec_fixed = dec.replace(/{\"error_code\":([-0-9]+)[^,}](.*)/gm, '{\"error_code\":\"$1\",$2');\n    }\n\n    this.log.debug(\"decrypted fixed: \" + dec_fixed);\n\n    return dec_fixed;\n  }\n\n  private calculateKey(local_seed: Buffer, remote_seed: Buffer, auth_hash: Buffer) {\n    const buf = Buffer.concat([Buffer.from(\"lsk\"), local_seed, remote_seed, auth_hash]);\n    const hash = this._crypto.createHash(\"sha256\").update(buf).digest();\n    this.key = hash.subarray(0, 16);\n  }\n\n  private calculateIvSeq(local_seed: Buffer, remote_seed: Buffer, auth_hash: Buffer) {\n    const buf = Buffer.concat([Buffer.from(\"iv\"), local_seed, remote_seed, auth_hash]);\n    const ivBuf = this._crypto.createHash(\"sha256\").update(buf).digest();\n    this.seq = ivBuf.subarray(-4).readInt32BE(0);\n    this.iv = ivBuf.subarray(0, 12);\n  }\n\n  private calculateSig(local_seed: Buffer, remote_seed: Buffer, auth_hash: Buffer) {\n    const payload = Buffer.concat([Buffer.from(\"ldk\"), local_seed, remote_seed, auth_hash]);\n    this.sig = this._crypto.createHash(\"sha256\").update(payload).digest().subarray(0, 28);\n  }\n\n  private ivSeqPair() {\n    const seq = Buffer.alloc(4);\n    seq.writeInt32BE(this.seq, 0);\n    return Buffer.concat([this.iv, seq]);\n  }\n}\n"],
  "mappings": "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",
  "names": ["crypto"]
}
