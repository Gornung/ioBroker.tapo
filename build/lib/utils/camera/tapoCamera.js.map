{
  "version": 3,
  "sources": ["../../../../src/lib/utils/camera/tapoCamera.ts"],
  "sourcesContent": ["import fetch, { RequestInit } from \"node-fetch\";\nimport https, { Agent } from \"https\";\nimport crypto from \"crypto\";\nimport { OnvifCamera } from \"./onvifCamera\";\nimport type {\n  TAPOCameraEncryptedRequest,\n  TAPOCameraEncryptedResponse,\n  TAPOCameraRequest,\n  TAPOCameraResponse,\n  TAPOCameraResponseDeviceInfo,\n  TAPOCameraResponseGetAlert,\n  TAPOCameraResponseGetLensMask,\n} from \"./types/tapo\";\n\nconst MAX_LOGIN_RETRIES = 3;\nconst AES_BLOCK_SIZE = 16;\n\ntype CameraConfig = {\n  name: string;\n  ipAddress: string;\n  username: string;\n  password: string;\n  streamUser: string;\n  streamPassword: string;\n\n  pullInterval?: number;\n  disableStreaming?: boolean;\n  disablePrivacyAccessory?: boolean;\n  disableAlarmAccessory?: boolean;\n  disableMotionAccessory?: boolean;\n  lowQuality?: boolean;\n\n  videoConfig?: VideoConfig;\n\n  privacyAccessoryName?: string;\n  alarmAccessoryName?: string;\n};\nexport class TAPOCamera extends OnvifCamera {\n  private readonly kStreamPort = 554;\n  private readonly httpsAgent: Agent;\n\n  private readonly hashedMD5Password: string;\n  private readonly hashedSha256Password: string;\n  private passwordEncryptionMethod: \"md5\" | \"sha256\" | null = null;\n\n  private isSecureConnectionValue: boolean | null = null;\n\n  private stokPromise: (() => Promise<string>) | undefined;\n\n  private readonly cnonce: string;\n  private lsk: Buffer | undefined;\n  private ivb: Buffer | undefined;\n  private seq: number | undefined;\n  private stok: string | undefined;\n\n  private loginRetryCount = 0;\n\n  constructor(\n    protected readonly log: any,\n    protected readonly config: CameraConfig,\n  ) {\n    super(log, config);\n    this.log.debug(\"Constructing Camera on host: \" + config.ipAddress);\n\n    this.httpsAgent = new https.Agent({\n      rejectUnauthorized: false,\n    });\n\n    this.cnonce = this.generateCnonce();\n\n    this.hashedMD5Password = crypto.createHash(\"md5\").update(config.password).digest(\"hex\").toUpperCase();\n    this.hashedSha256Password = crypto.createHash(\"sha256\").update(config.password).digest(\"hex\").toUpperCase();\n  }\n\n  private getUsername() {\n    return this.config.username || \"admin\";\n  }\n\n  private getHeaders() {\n    const headers: Record<string, string> = {\n      Host: `https://${this.config.ipAddress}`,\n      Referer: `https://${this.config.ipAddress}`,\n      Accept: \"application/json\",\n      \"Accept-Encoding\": \"gzip, deflate\",\n      \"User-Agent\": \"Tapo CameraClient Android\",\n      Connection: \"close\",\n      requestByApp: \"true\",\n      \"Content-Type\": \"application/json; charset=UTF-8\",\n    };\n    return headers;\n  }\n\n  private getHashedPassword() {\n    if (this.passwordEncryptionMethod === \"md5\") {\n      return this.hashedMD5Password;\n    } else if (this.passwordEncryptionMethod === \"sha256\") {\n      return this.hashedSha256Password;\n    } else {\n      throw new Error(\"Unknown password encryption method\");\n    }\n  }\n\n  private fetch(url: string, data: RequestInit) {\n    return fetch(url, {\n      agent: this.httpsAgent,\n      headers: this.getHeaders(),\n      ...data,\n    });\n  }\n\n  private generateEncryptionToken(tokenType: string, nonce: string): Buffer {\n    const hashedKey = crypto\n      .createHash(\"sha256\")\n      .update(this.cnonce + this.getHashedPassword() + nonce)\n      .digest(\"hex\")\n      .toUpperCase();\n    return crypto\n      .createHash(\"sha256\")\n      .update(tokenType + this.cnonce + nonce + hashedKey)\n      .digest()\n      .slice(0, 16);\n  }\n\n  getAuthenticatedStreamUrl(lowQuality = false) {\n    const prefix = `rtsp://${this.config.streamUser}:${this.config.streamPassword}@${this.config.ipAddress}:${this.kStreamPort}`;\n    return lowQuality ? `${prefix}/stream2` : `${prefix}/stream1`;\n  }\n\n  private generateCnonce() {\n    return crypto.randomBytes(8).toString(\"hex\").toUpperCase();\n  }\n\n  private validateDeviceConfirm(nonce: string, deviceConfirm: string) {\n    const hashedNoncesWithSHA256 = crypto\n      .createHash(\"sha256\")\n      .update(this.cnonce + this.hashedSha256Password + nonce)\n      .digest(\"hex\")\n      .toUpperCase();\n    const hashedNoncesWithMD5 = crypto\n      .createHash(\"md5\")\n      .update(this.cnonce + this.hashedMD5Password + nonce)\n      .digest(\"hex\")\n      .toUpperCase();\n\n    if (deviceConfirm === hashedNoncesWithSHA256 + nonce + this.cnonce) {\n      this.passwordEncryptionMethod = \"sha256\";\n      return true;\n    }\n\n    if (deviceConfirm === hashedNoncesWithMD5 + nonce + this.cnonce) {\n      this.passwordEncryptionMethod = \"md5\";\n      return true;\n    }\n\n    return false;\n  }\n\n  async refreshStok(loginRetryCount = 0): Promise<string> {\n    const isSecureConnection = await this.isSecureConnection();\n\n    let response = null;\n    let responseData = null;\n\n    let fetchParams = {};\n    if (isSecureConnection) {\n      this.log.debug(\"StokRefresh: Using secure connection\");\n      fetchParams = {\n        method: \"post\",\n        body: JSON.stringify({\n          method: \"login\",\n          params: {\n            cnonce: this.cnonce,\n            encrypt_type: \"3\",\n            username: this.getUsername(),\n          },\n        }),\n      };\n    } else {\n      this.log.debug(\"StokRefresh: Using unsecure connection\");\n      fetchParams = {\n        method: \"post\",\n        body: JSON.stringify({\n          method: \"login\",\n          params: {\n            username: this.getUsername(),\n            password: this.getHashedPassword(),\n            hashed: true,\n          },\n        }),\n      };\n    }\n\n    response = await this.fetch(`https://${this.config.ipAddress}`, fetchParams);\n    responseData = await response.json();\n\n    this.log.debug(\"StokRefresh: Login response :>> \", response.status, JSON.stringify(responseData));\n\n    if (response.status === 401) {\n      if (responseData?.result?.data?.code === 40411) {\n        throw new Error(\"Invalid credentials\");\n      }\n    }\n\n    if (isSecureConnection) {\n      this.log.debug(\"StokRefresh: Using secure connection\");\n      const nonce = responseData?.result?.data?.nonce;\n      const deviceConfirm = responseData?.result?.data?.device_confirm;\n\n      if (nonce && deviceConfirm && this.validateDeviceConfirm(nonce, deviceConfirm)) {\n        const digestPasswd = crypto\n          .createHash(\"sha256\")\n          .update(this.getHashedPassword() + this.cnonce + nonce)\n          .digest(\"hex\")\n          .toUpperCase();\n\n        const digestPasswdFull = Buffer.concat([\n          Buffer.from(digestPasswd, \"utf8\"),\n          Buffer.from(this.cnonce!, \"utf8\"),\n          Buffer.from(nonce, \"utf8\"),\n        ]).toString(\"utf8\");\n\n        response = await this.fetch(`https://${this.config.ipAddress}`, {\n          method: \"POST\",\n          body: JSON.stringify({\n            method: \"login\",\n            params: {\n              cnonce: this.cnonce,\n              encrypt_type: \"3\",\n              digest_passwd: digestPasswdFull,\n              username: this.getUsername(),\n            },\n          }),\n        });\n\n        responseData = await response.json();\n\n        this.log.debug(\"StokRefresh: Start_seq response :>>\", response.status, JSON.stringify(responseData));\n\n        if (responseData?.result?.start_seq) {\n          if (responseData?.result?.user_group !== \"root\") {\n            // # encrypted control via 3rd party account does not seem to be supported\n            // # see https://github.com/JurajNyiri/HomeAssistant-Tapo-Control/issues/456\n            throw new Error(\"Incorrect user_group detected\");\n          }\n\n          this.lsk = this.generateEncryptionToken(\"lsk\", nonce);\n          this.ivb = this.generateEncryptionToken(\"ivb\", nonce);\n          this.seq = responseData.result.start_seq;\n        }\n      }\n    } else {\n      this.passwordEncryptionMethod = \"md5\";\n    }\n\n    if (responseData?.result?.data?.sec_left > 0) {\n      throw new Error(`StokRefresh: Temporary Suspension: Try again in ${responseData.result.data.sec_left} seconds`);\n    }\n\n    if (responseData?.data?.code == -40404 && responseData?.data?.sec_left > 0) {\n      throw new Error(`StokRefresh: Temporary Suspension: Try again in ${responseData.data.sec_left} seconds`);\n    }\n\n    if (responseData?.result?.stok) {\n      this.stok = responseData.result.stok;\n      this.log.debug(\"StokRefresh: Success :>>\", this.stok);\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return this.stok!;\n    }\n\n    if (responseData?.error_code === -40413 && loginRetryCount < MAX_LOGIN_RETRIES) {\n      this.log.debug(\n        `Unexpected response, retrying: ${loginRetryCount}/${MAX_LOGIN_RETRIES}.`,\n        response.status,\n        JSON.stringify(responseData),\n      );\n      return this.refreshStok(loginRetryCount + 1);\n    }\n\n    throw new Error(\"Invalid authentication data\");\n  }\n\n  async isSecureConnection() {\n    if (this.isSecureConnectionValue === null) {\n      const response = await this.fetch(`https://${this.config.ipAddress}`, {\n        method: \"post\",\n        body: JSON.stringify({\n          method: \"login\",\n          params: {\n            encrypt_type: \"3\",\n            username: this.getUsername(),\n          },\n        }),\n      });\n      this.log.debug(JSON.stringify(response));\n      const json = await response.json();\n\n      this.log.debug(\"isSecureConnection response :>> \", response.status, json);\n\n      this.isSecureConnectionValue = json.error_code == -40413 && json?.result?.data?.encrypt_type?.includes(\"3\");\n    }\n\n    return this.isSecureConnectionValue;\n  }\n\n  getStok(loginRetryCount = 0): Promise<string> {\n    if (this.stok) {\n      return new Promise((resolve) => resolve(this.stok!));\n    }\n\n    if (!this.stokPromise) {\n      this.stokPromise = () => this.refreshStok(loginRetryCount);\n    }\n\n    return this.stokPromise()\n      .then(() => {\n        return this.stok!;\n      })\n      .finally(() => {\n        this.stokPromise = undefined;\n      });\n  }\n\n  private async getAuthenticatedAPIURL(loginRetryCount = 0) {\n    const token = await this.getStok(loginRetryCount);\n    return `https://${this.config.ipAddress}/stok=${token}/ds`;\n  }\n\n  encryptRequest(request: string) {\n    const cipher = crypto.createCipheriv(\"aes-128-cbc\", this.lsk!, this.ivb!);\n    let ct_bytes = cipher.update(this.encryptPad(request, AES_BLOCK_SIZE), \"utf-8\", \"hex\");\n    ct_bytes += cipher.final(\"hex\");\n    return Buffer.from(ct_bytes, \"hex\");\n  }\n\n  private encryptPad(text: string, blocksize: number) {\n    const padSize = blocksize - (text.length % blocksize);\n    const padding = String.fromCharCode(padSize).repeat(padSize);\n    return text + padding;\n  }\n\n  private decryptResponse(response: string): string {\n    const decipher = crypto.createDecipheriv(\"aes-128-cbc\", this.lsk!, this.ivb!);\n    let decrypted = decipher.update(response, \"base64\", \"utf-8\");\n    decrypted += decipher.final(\"utf-8\");\n    return this.encryptUnpad(decrypted, AES_BLOCK_SIZE);\n  }\n\n  private encryptUnpad(text: string, blockSize: number): string {\n    const paddingLength = Number(text[text.length - 1]) || 0;\n    if (paddingLength > blockSize || paddingLength > text.length) {\n      throw new Error(\"Invalid padding\");\n    }\n    for (let i = text.length - paddingLength; i < text.length; i++) {\n      if (text.charCodeAt(i) !== paddingLength) {\n        throw new Error(\"Invalid padding\");\n      }\n    }\n    return text.slice(0, text.length - paddingLength).toString();\n  }\n\n  private getTapoTag(request: TAPOCameraEncryptedRequest) {\n    const tag = crypto\n      .createHash(\"sha256\")\n      .update(this.getHashedPassword() + this.cnonce)\n      .digest(\"hex\")\n      .toUpperCase();\n    return crypto\n      .createHash(\"sha256\")\n      .update(tag + JSON.stringify(request) + this.seq!.toString())\n      .digest(\"hex\")\n      .toUpperCase();\n  }\n\n  private pendingAPIRequests: Map<string, Promise<TAPOCameraResponse>> = new Map();\n\n  private async apiRequest(req: TAPOCameraRequest, loginRetryCount = 0): Promise<TAPOCameraResponse> {\n    const reqJson = JSON.stringify(req);\n\n    if (this.pendingAPIRequests.has(reqJson)) {\n      return this.pendingAPIRequests.get(reqJson) as Promise<TAPOCameraResponse>;\n    }\n\n    this.log.debug(\"API new request\", reqJson);\n\n    this.pendingAPIRequests.set(\n      reqJson,\n      (async () => {\n        try {\n          const isSecureConnection = await this.isSecureConnection();\n          const url = await this.getAuthenticatedAPIURL(loginRetryCount);\n\n          const fetchParams: RequestInit = {\n            method: \"post\",\n          };\n\n          if (this.seq && isSecureConnection) {\n            const encryptedRequest: TAPOCameraEncryptedRequest = {\n              method: \"securePassthrough\",\n              params: {\n                request: Buffer.from(this.encryptRequest(JSON.stringify(req))).toString(\"base64\"),\n              },\n            };\n            fetchParams.headers = {\n              ...this.getHeaders(),\n              Tapo_tag: this.getTapoTag(encryptedRequest),\n              Seq: this.seq.toString(),\n            };\n            fetchParams.body = JSON.stringify(encryptedRequest);\n            this.seq += 1;\n          } else {\n            fetchParams.body = JSON.stringify(req);\n          }\n\n          const response = await this.fetch(url, fetchParams);\n          let json = await response.json();\n\n          if (isSecureConnection) {\n            const encryptedResponse = json as TAPOCameraEncryptedResponse;\n            if (encryptedResponse.result.response) {\n              const decryptedResponse = this.decryptResponse(encryptedResponse.result.response);\n              json = JSON.parse(decryptedResponse) as TAPOCameraResponse;\n            }\n          } else {\n            json = json as TAPOCameraResponse;\n          }\n\n          this.log.debug(`API response`, response.status, JSON.stringify(json));\n\n          // Apparently the Tapo C200 returns 500 on successful requests,\n          // but it's indicating an expiring token, therefore refresh the token next time\n          if (isSecureConnection && response.status === 500) {\n            this.stok = undefined;\n          }\n\n          // Check if we have to refresh the token\n          if (json.error_code === -40401 || json.error_code === -1) {\n            this.log.debug(\"API request failed, reauthenticating\");\n            this.stok = undefined;\n            return this.apiRequest(req, loginRetryCount + 1);\n          }\n\n          return json as TAPOCameraResponse;\n        } finally {\n          this.pendingAPIRequests.delete(reqJson);\n        }\n      })(),\n    );\n\n    return this.pendingAPIRequests.get(reqJson) as Promise<TAPOCameraResponse>;\n  }\n\n  async setLensMaskConfig(value: boolean) {\n    this.log.debug(\"Processing setLensMaskConfig\", value);\n\n    const json = await this.apiRequest({\n      method: \"multipleRequest\",\n      params: {\n        requests: [\n          {\n            method: \"setLensMaskConfig\",\n            params: {\n              lens_mask: {\n                lens_mask_info: {\n                  enabled: value ? \"on\" : \"off\",\n                },\n              },\n            },\n          },\n        ],\n      },\n    });\n\n    if (json.error_code !== 0) {\n      throw new Error(\"Failed to perform action\");\n    }\n  }\n\n  async setAlertConfig(value: boolean) {\n    this.log.debug(\"Processing setAlertConfig\", value);\n\n    const json = await this.apiRequest({\n      method: \"multipleRequest\",\n      params: {\n        requests: [\n          {\n            method: \"setAlertConfig\",\n            params: {\n              msg_alarm: {\n                chn1_msg_alarm_info: {\n                  enabled: value ? \"on\" : \"off\",\n                },\n              },\n            },\n          },\n        ],\n      },\n    });\n\n    return json.error_code !== 0;\n  }\n  async setForceWhitelampState(value: boolean) {\n    const json = await this.apiRequest({\n      method: \"multipleRequest\",\n      params: {\n        requests: [\n          {\n            method: \"setForceWhitelampState\",\n            params: {\n              image: {\n                switch: {\n                  force_wtl_state: value ? \"on\" : \"off\",\n                },\n              },\n            },\n          },\n        ],\n      },\n    });\n\n    return json.error_code !== 0;\n  }\n  async moveMotorStep(angle: number) {\n    const json = await this.apiRequest({\n      method: \"multipleRequest\",\n      params: {\n        requests: [{ method: \"do\", motor: { movestep: { direction: angle } } }],\n      },\n    });\n\n    return json.error_code !== 0;\n  }\n\n  async moveMotor(x: number, y: number) {\n    const json = await this.apiRequest({\n      method: \"multipleRequest\",\n      params: {\n        requests: [{ method: \"do\", motor: { move: { x_coord: x, y_coord: y } } }],\n      },\n    });\n\n    return json.error_code !== 0;\n  }\n\n  async getBasicInfo() {\n    const json = await this.apiRequest({\n      method: \"multipleRequest\",\n      params: {\n        requests: [\n          {\n            method: \"getDeviceInfo\",\n            params: {\n              device_info: {\n                name: [\"basic_info\"],\n              },\n            },\n          },\n        ],\n      },\n    });\n\n    const info = json.result.responses[0] as TAPOCameraResponseDeviceInfo;\n    return info.result.device_info.basic_info;\n  }\n\n  async getStatus(): Promise<{ lensMask: boolean; alert: boolean }> {\n    const json = await this.apiRequest({\n      method: \"multipleRequest\",\n      params: {\n        requests: [\n          {\n            method: \"getAlertConfig\",\n            params: {\n              msg_alarm: {\n                name: \"chn1_msg_alarm_info\",\n              },\n            },\n          },\n          {\n            method: \"getLensMaskConfig\",\n            params: {\n              lens_mask: {\n                name: \"lens_mask_info\",\n              },\n            },\n          },\n          {\n            method: \"getForceWhitelampState\",\n            params: {\n              image: {\n                name: \"switch\",\n              },\n            },\n          },\n        ],\n      },\n    });\n    this.log.debug(`getStatus json: ${JSON.stringify(json)}`);\n    if (json.error_code !== 0) {\n      throw new Error(\"Camera replied with error\");\n    }\n    if (!json.result.responses) {\n      throw new Error(\"Camera replied with invalid response\");\n    }\n    const alertConfig = json.result.responses.find((r) => r.method === \"getAlertConfig\") as TAPOCameraResponseGetAlert;\n\n    const forceWhitelampState = json.result.responses.find((r) => r.method === \"getForceWhitelampState\") as TAPOCameraResponseGetForce;\n    const lensMaskConfig = json.result.responses.find((r) => r.method === \"getLensMaskConfig\") as TAPOCameraResponseGetLensMask;\n\n    return {\n      alert: alertConfig.result.msg_alarm.chn1_msg_alarm_info.enabled === \"on\",\n      lensMask: lensMaskConfig.result.lens_mask.lens_mask_info.enabled === \"on\",\n      forceWhiteLamp: forceWhitelampState.result.image ? forceWhitelampState.result.image.switch.force_wtl_state === \"on\" : false,\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": ["https", "crypto", "fetch"]
}
